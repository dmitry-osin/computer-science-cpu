# Оглавление: Принципы работы процессора  

---

## 1. Основы цифровой логики  
### 1.1. Двоичная система и логические операции  
#### 1.1.1. Представление данных в двоичном виде (биты, байты)  
#### 1.1.2. Логические вентили: AND, OR, NOT, XOR, NAND  
#### 1.1.3. Булева алгебра и её применение в схемах процессора  
### 1.2. Триггеры и регистры  
#### 1.2.1. Как хранится бит информации (RS-триггер, D-триггер)  
#### 1.2.2. Роль регистров в процессоре  

---

## 2. Архитектура процессора  
### 2.1. Цикл выполнения инструкций (Fetch-Decode-Execute)  
#### 2.1.1. Этапы: выборка, декодирование, выполнение, запись  
#### 2.1.2. Роль счетчика команд (Program Counter) и регистра команд (Instruction Register)  
### 2.2. Основные компоненты ЦПУ  
#### 2.2.1. АЛУ (арифметико-логическое устройство)  
#### 2.2.2. Блок управления (Control Unit)  
#### 2.2.3. Система регистров (аккумулятор, регистр флагов)  
### 2.3. Шины данных, адреса и управления  
#### 2.3.1. Как данные перемещаются между компонентами  

---

## 3. Система команд (Instruction Set Architecture, ISA)  
### 3.1. Типы инструкций  
#### 3.1.1. Арифметические (ADD, SUB), логические (AND, OR), управляющие (JUMP, CALL)  
#### 3.1.2. Работа с памятью (LOAD, STORE)  
### 3.2. Форматы инструкций  
#### 3.2.1. RISC (фиксированная длина) vs CISC (переменная длина)  
#### 3.2.2. Примеры: x86 (CISC), ARM (RISC)  
### 3.3. Адресация данных  
#### 3.3.1. Непосредственная, регистровая, косвенная, индексная адресация  

---

## 4. Микроархитектура  
### 4.1. Конвейеризация (Pipeline)  
#### 4.1.1. Разделение цикла выполнения на этапы (например, 5-ступенчатый конвейер)  
#### 4.1.2. Проблемы: конфликты данных (data hazards) и их решение  
### 4.2. Параллелизм на уровне инструкций  
#### 4.2.1. Суперскалярная архитектура: выполнение нескольких инструкций за такт  
#### 4.2.2. Out-of-Order Execution (переупорядочивание команд)  
### 4.3. Спекулятивное выполнение  
#### 4.3.1. Предсказание ветвлений (Branch Prediction)  

---

## 5. Память и кэширование  
### 5.1. Иерархия памяти  
#### 5.1.1. Регистры → Кэш L1/L2/L3 → ОЗУ → Диск  
#### 5.1.2. Принцип локальности данных (временная и пространственная)  
### 5.2. Кэш-память  
#### 5.2.1. Ассоциативность кэша (прямое отображение, наборно-ассоциативный)  
#### 5.2.2. Алгоритмы замены данных (LRU, FIFO)  
### 5.3. Виды памяти  
#### 5.3.1. SRAM (кэш), DRAM (ОЗУ), ROM  

---

## 6. Многоядерные и многопоточные процессоры  
### 6.1. Многоядерность  
#### 6.1.1. Как ядра делят задачи (SMP, NUMA)  
#### 6.1.2. Синхронизация: мьютексы, семафоры  
### 6.2. Многопоточность  
#### 6.2.1. Hyper-Threading (одно ядро выполняет несколько потоков)  
### 6.3. Параллельные архитектуры  
#### 6.3.1. GPU vs CPU: различия в подходах к вычислениям  

---

## 7. Производительность и оптимизация  
### 7.1. Тактовая частота  
#### 7.1.1. Как частота влияет на скорость выполнения инструкций  
### 7.2. CPI (Cycles Per Instruction)  
#### 7.2.1. Метрика для оценки эффективности архитектуры  
### 7.3. Закон Амдала  
#### 7.3.1. Ограничения параллельных вычислений  
### 7.4. Тепловыделение и энергоэффективность  
#### 7.4.1. Почему современные процессоры не могут бесконечно расти в частоте  

---

## 8. Современные технологии  
### 8.1. Векторные инструкции (SIMD)  
#### 8.1.1. SSE, AVX, NEON: ускорение обработки данных  
### 8.2. Квантовые процессоры (обзор)  
#### 8.2.1. Принципиальные отличия от классических ЦПУ  
### 8.3. RISC-V и открытые архитектуры  
#### 8.3.1. Тренды в разработке процессоров  

---

## 9. Практические аспекты  
### 9.1. Симуляторы процессоров  
#### 9.1.1. Примеры: Logisim, MARS (MIPS), QEMU  
### 9.2. Ассемблер и низкоуровневое программирование  
#### 9.2.1. Написание простых программ на ассемблере (например, сложение чисел)  
### 9.3. Анализ производительности  
#### 9.3.1. Инструменты: perf, VTune, профилировщики  

---

## 10. Исторический контекст  
### 10.1. Эволюция процессоров  
#### 10.1.1. От Intel 4004 (1971) до современных многоядерных CPU  
### 10.2. Архитектурные прорывы  
#### 10.2.1. Переход от 32-битных к 64-битным системам  
#### 10.2.2. Появление кэш-памяти и конвейеризации 